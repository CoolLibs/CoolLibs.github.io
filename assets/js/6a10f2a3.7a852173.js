"use strict";(self.webpackChunkcool_docs=self.webpackChunkcool_docs||[]).push([[312],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var r=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=r.createContext({}),u=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(a),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||l;return a?r.createElement(h,n(n({ref:t},p),{},{components:a})):r.createElement(h,n({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,n=new Array(l);n[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,n[1]=o;for(var u=2;u<l;u++)n[u]=a[u];return r.createElement.apply(null,n)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4119:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return p},default:function(){return c}});var r=a(7462),i=a(3366),l=(a(7294),a(3905)),n=["components"],o={title:"Our Roadmap",toc:!0},s=void 0,u={unversionedId:"lab/our-roadmap",id:"lab/our-roadmap",title:"Our Roadmap",description:"\u2705 Done",source:"@site/docs/lab/04-our-roadmap.md",sourceDirName:"lab",slug:"/lab/our-roadmap",permalink:"/lab/our-roadmap",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Our Roadmap",toc:!0},sidebar:"lab",previous:{title:"Our Philosophy",permalink:"/lab/our-philosophy"}},p=[{value:"\u2705 Done",id:"-done",children:[{value:"Node system",id:"node-system",children:[],level:3},{value:"Ray Marching",id:"ray-marching",children:[],level:3},{value:"Parameter system",id:"parameter-system",children:[],level:3}],level:2},{value:"\ud83d\udea7 Doing",id:"-doing",children:[{value:"Abstract GPU API",id:"abstract-gpu-api",children:[],level:3},{value:"Setup a material system",id:"setup-a-material-system",children:[],level:3},{value:"Write libraries of shader functions",id:"write-libraries-of-shader-functions",children:[],level:3},{value:"Meta language on top of glsl",id:"meta-language-on-top-of-glsl",children:[],level:3}],level:2},{value:"\ud83d\udcaa To Do",id:"-to-do",children:[{value:"Post-processing",id:"post-processing",children:[],level:3},{value:"Layer system",id:"layer-system",children:[],level:3},{value:"Color palettes",id:"color-palettes",children:[],level:3},{value:"Audio",id:"audio",children:[],level:3},{value:"Compile for the web",id:"compile-for-the-web",children:[],level:3},{value:"History / Multiple histories in parallel ?",id:"history--multiple-histories-in-parallel-",children:[],level:3},{value:"Lights system",id:"lights-system",children:[],level:3},{value:"Simple compute shaders",id:"simple-compute-shaders",children:[],level:3},{value:"Project save",id:"project-save",children:[],level:3},{value:"Color spaces ?",id:"color-spaces-",children:[],level:3},{value:"Bezier instead of interpolation for function curves (a.k.a. RGB curves).",id:"bezier-instead-of-interpolation-for-function-curves-aka-rgb-curves",children:[],level:3},{value:"Premultiplied alpha",id:"premultiplied-alpha",children:[],level:3},{value:"Improve timeline navigation / display",id:"improve-timeline-navigation--display",children:[],level:3},{value:"Keybinds remapping (inspired from Django ?)",id:"keybinds-remapping-inspired-from-django-",children:[],level:3},{value:"Scripting",id:"scripting",children:[],level:3}],level:2}],d={toc:p};function c(e){var t=e.components,a=(0,i.Z)(e,n);return(0,l.kt)("wrapper",(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"-done"},"\u2705 Done"),(0,l.kt)("h3",{id:"node-system"},"Node system"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Integrate a library to create node graphs and use it to create scenes."),(0,l.kt)("li",{parentName:"ul"},"Make it easy for any user to add new nodes.")),(0,l.kt)("h3",{id:"ray-marching"},"Ray Marching"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Generate a shader that contains the sdf of the scene (described by the node graph)."),(0,l.kt)("li",{parentName:"ul"},"Render that scene within the same shader."),(0,l.kt)("li",{parentName:"ul"},"Implement many cool rendering effects that are allowed by Ray Marching.")),(0,l.kt)("h3",{id:"parameter-system"},"Parameter system"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Control them through the UI"),(0,l.kt)("li",{parentName:"ul"},"Save changes to them in a history"),(0,l.kt)("li",{parentName:"ul"},"Be able to create presets")),(0,l.kt)("h2",{id:"-doing"},"\ud83d\udea7 Doing"),(0,l.kt)("h3",{id:"abstract-gpu-api"},"Abstract GPU API"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Create generic classes that can be implemented both with OpenGL and Vulkan to abstract those away and allow users to write cross-platform code."),(0,l.kt)("li",{parentName:"ul"},"Add even more APIs, like WebGPU."),(0,l.kt)("li",{parentName:"ul"},"Add a type-safe C++ wrapper around OpenGL: ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/CoolLibs/glpp"},"GL++"),".")),(0,l.kt)("h3",{id:"setup-a-material-system"},"Setup a material system"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Have PBR materials and a UI for them."),(0,l.kt)("li",{parentName:"ul"},"Attach those materials to objects in the is0 scene.")),(0,l.kt)("h3",{id:"write-libraries-of-shader-functions"},"Write libraries of shader functions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Group common functions in libraries:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Camera and 3D geometry"),(0,l.kt)("li",{parentName:"ul"},"Random"),(0,l.kt)("li",{parentName:"ul"},"PBR calculations"),(0,l.kt)("li",{parentName:"ul"},"Color conversions")))),(0,l.kt)("h3",{id:"meta-language-on-top-of-glsl"},"Meta language on top of glsl"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Add a ",(0,l.kt)("inlineCode",{parentName:"li"},"#include")," directive."),(0,l.kt)("li",{parentName:"ul"},"Add recursive functions."),(0,l.kt)("li",{parentName:"ul"},"Do generic glsl parsing: look at ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/google/shaderc"},"shaderc")," (",(0,l.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=SXDlZRDjtXg"},"https://www.youtube.com/watch?v=SXDlZRDjtXg"),") and ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/gfx-rs/naga"},"naga"),".")),(0,l.kt)("h2",{id:"-to-do"},"\ud83d\udcaa To Do"),(0,l.kt)("h3",{id:"post-processing"},"Post-processing"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here is a ",(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/Y3d8jR_IwYw?t=4378"},"great inspiration"),". Especially the gradient technique is pretty cool."),(0,l.kt)("li",{parentName:"ul"},"Here is a very good resource about ",(0,l.kt)("a",{parentName:"li",href:"https://youtu.be/tI70-HIc5ro"},"bloom"),"."),(0,l.kt)("li",{parentName:"ul"},"Here is a discussion of ",(0,l.kt)("a",{parentName:"li",href:"https://alexanderameye.github.io/notes/rendering-outlines/"},"outlines effects")," (the edge-detection one is particularly good).")),(0,l.kt)("h3",{id:"layer-system"},"Layer system"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Think about the design: How do we combine the outputs from our different systems or from different instances of the same system.\nDo we use a classic layer structure, or a graph?")),(0,l.kt)("p",null,"One module = something that takes inputs and gives us outputs (often images (color, depth, mask (\\approx_equal alpha) etc.)). E.g. : is0, the color grader, the depth of field effect etc.\nInputs can also be a camera for example. So that we can decide if the different modules share the same 3D camera or not."),(0,l.kt)("p",null,"The modules are composited in a graph system: you connect images outputed by one as input to another."),(0,l.kt)("p",null,"Users should be able to create entire modules as plugins that they can add to CoolLab easily."),(0,l.kt)("h3",{id:"color-palettes"},"Color palettes"),(0,l.kt)("p",null,"Use ",(0,l.kt)("a",{parentName:"p",href:"https://iquilezles.org/www/articles/palettes/palettes.htm"},"IQ's color palettes")," everywhere!"),(0,l.kt)("p",null,"Can we generate an IQ palette from a discrete palette with colors hand-picked by an artist?"),(0,l.kt)("h3",{id:"audio"},"Audio"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Import audio files and play them along the image generation (ideal to produce audio clips)."),(0,l.kt)("li",{parentName:"ul"},"Retrieve data from the audio to drive the images (pitch, bpm, volume etc.)."),(0,l.kt)("li",{parentName:"ul"},"We can search a lib in ",(0,l.kt)("a",{parentName:"li",href:"https://awesomeopensource.com/projects/audio-library"},"this list"),". I currently found ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/mackron/miniaudio"},"miniaudio")," for audio playback and ",(0,l.kt)("a",{parentName:"li",href:"https://www.kfrlib.com/newdocs/index.html"},"kfrlib")," or ",(0,l.kt)("a",{parentName:"li",href:"https://aubio.org/"},"aubio")," for audio analysis.")),(0,l.kt)("h3",{id:"compile-for-the-web"},"Compile for the web"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use emscripten and WebGL (or WebGPU) to be able to run our software in the browser.")),(0,l.kt)("h3",{id:"history--multiple-histories-in-parallel-"},"History / Multiple histories in parallel ?"),(0,l.kt)("h3",{id:"lights-system"},"Lights system"),(0,l.kt)("h3",{id:"simple-compute-shaders"},"Simple compute shaders"),(0,l.kt)("h3",{id:"project-save"},"Project save"),(0,l.kt)("h3",{id:"color-spaces-"},"Color spaces ?"),(0,l.kt)("h3",{id:"bezier-instead-of-interpolation-for-function-curves-aka-rgb-curves"},"Bezier instead of interpolation for function curves (a.k.a. RGB curves)."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/CoolLibs/Cool/blob/main/src/Cool/RgbCurve/_README.md"},"Bezier Rgb Curves")),(0,l.kt)("p",null,"And how do we send these curves to the shader ? Do we bake it into a texture ?"),(0,l.kt)("h3",{id:"premultiplied-alpha"},"Premultiplied alpha"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://youtu.be/WtYfF48Z9mA?list=PL9_jI1bdZmz2emSh0UQ5iOdT2xRHFHL7E"},"https://youtu.be/WtYfF48Z9mA?list=PL9_jI1bdZmz2emSh0UQ5iOdT2xRHFHL7E")),(0,l.kt)("h3",{id:"improve-timeline-navigation--display"},"Improve timeline navigation / display"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://youtu.be/Y3d8jR_IwYw?t=5577"},"https://youtu.be/Y3d8jR_IwYw?t=5577")),(0,l.kt)("h3",{id:"keybinds-remapping-inspired-from-django-"},"Keybinds remapping (inspired from Django ?)"),(0,l.kt)("h3",{id:"scripting"},"Scripting"),(0,l.kt)("p",null,"Everythin that is doable from the UI should be doable via scripting."),(0,l.kt)("p",null,"For the language I really like Typescript, but all options should be considered."))}c.isMDXComponent=!0}}]);