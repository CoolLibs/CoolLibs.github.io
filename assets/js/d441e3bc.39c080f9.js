"use strict";(self.webpackChunkcool_docs=self.webpackChunkcool_docs||[]).push([[772],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return h}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(r),h=i,f=d["".concat(l,".").concat(h)]||d[h]||p[h]||a;return r?n.createElement(f,o(o({ref:t},c),{},{components:r})):n.createElement(f,o({ref:t},c))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<a;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7552:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var n=r(7462),i=r(3366),a=(r(7294),r(3905)),o=["components"],s={},l=void 0,u={unversionedId:"lab/Writing Nodes/Color Spaces",id:"lab/Writing Nodes/Color Spaces",title:"Color Spaces",description:"All our user inputs are in sRGB, straight alpha space.",source:"@site/docs/lab/03-Writing Nodes/04-Color Spaces.md",sourceDirName:"lab/03-Writing Nodes",slug:"/lab/Writing Nodes/Color Spaces",permalink:"/lab/Writing Nodes/Color Spaces",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"lab",previous:{title:"Output Indices",permalink:"/lab/Writing Nodes/Output Indices"},next:{title:"Our Philosophy",permalink:"/lab/Dev/our-philosophy"}},c=[{value:"CIELAB",id:"cielab",children:[],level:3},{value:"Linear RGB",id:"linear-rgb",children:[],level:3},{value:"sRGB",id:"srgb",children:[],level:3}],p={toc:c};function d(e){var t=e.components,r=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"All our user inputs are in ",(0,a.kt)("strong",{parentName:"p"},"sRGB, straight alpha")," space.",(0,a.kt)("br",null),"\nBUT when the shader asks for some ",(0,a.kt)("em",{parentName:"p"},"RGB")," or ",(0,a.kt)("em",{parentName:"p"},"RGBA"),", we use ",(0,a.kt)("strong",{parentName:"p"},"linear RGB and premultiplied alpha"),". Using premultiplied alpha means that things like blending and blurring will behave naturally (",(0,a.kt)("a",{parentName:"p",href:"https://youtu.be/WtYfF48Z9mA?list=PL9_jI1bdZmz2emSh0UQ5iOdT2xRHFHL7E&t=960"},"see this great lesson"),"). Linear RGB is better for most computations (see ",(0,a.kt)("a",{parentName:"p",href:"https://youtu.be/LKnqECcg6Gw"},"this")," (and also ",(0,a.kt)("a",{parentName:"p",href:"https://youtu.be/nIaczt4F2D4"},"this")," to see why Lab is even better)). Light-based effects should be done in linear (blur, chromatic aberration, addition, over, etc.); color-distance based effects should be done in Lab (gradient, mapping a color to the closest one in a set, etc.)"),(0,a.kt)("p",null,"NB: for RGB->RGB effects, if some RGBA is plugged in as input, we first un-premultiply the RGB, then pass it to the effect, then re-premultiply. This is the same behavior as ",(0,a.kt)("a",{parentName:"p",href:"https://youtu.be/klqSJiPqmGU"},'"Pre-Divide / Post-Multiply" in Resolve/Fusion'),". This basically means that everything will work as expected intuitively and you don't have to worry about it."),(0,a.kt)("h3",{id:"cielab"},"CIELAB"),(0,a.kt)("p",null,"In this space, the euclidean distance between the ",(0,a.kt)("inlineCode",{parentName:"p"},"vec3"),"s exactly corresponds to the perceived difference in color by a human. This means that if you need to do anything that is perceptually accurate, e.g. blending between two colors, CIELAB is what you need. This is the space that most effects will want to use."),(0,a.kt)("h3",{id:"linear-rgb"},"Linear RGB"),(0,a.kt)("p",null,"When doing physically-based rendering in 3D, you are using Linear RGB because you are manipulating amounts of light (photons) and adding them together."),(0,a.kt)("h3",{id:"srgb"},"sRGB"),(0,a.kt)("p",null,"This is the standard input and output format. Compared to Linear RGB, it matches our perception more closely (for example (0.5, 0.5, 0.5) in sRGB is perceived as a middle-grey, whereas (0.5, 0.5, 0.5) in Linear RGB is perceived as very bright, close to white). All the images you will use will almost certainly be stored as sRGB. This is why this is the default guess when CoolLab imports an image.\nThis is also what color pickers will give you, so this is the input format, used in our GUI. Effects hardly ever need to manipulate sRGB."))}d.isMDXComponent=!0}}]);