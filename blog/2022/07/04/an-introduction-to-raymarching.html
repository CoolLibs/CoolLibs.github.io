<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Cool RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Cool Atom Feed"><title data-react-helmet="true">Introduction to raymarching | Cool</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://coollibs.github.io//blog/2022/07/04/an-introduction-to-raymarching"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="Introduction to raymarching | Cool"><meta data-react-helmet="true" name="description" content="Cool is a software aimed at visual generative art, meaning it has to render - display a 2D or 3D scene onto a computer screen. To do so, Cool uses a specific technique called &quot;Ray Marching&quot; - fairly uncommon among computer graphic softwares, allowing for instance, a very quick rendering of scene with a lot of identical objects (a space filled with infinite spheres for example)."><meta data-react-helmet="true" property="og:description" content="Cool is a software aimed at visual generative art, meaning it has to render - display a 2D or 3D scene onto a computer screen. To do so, Cool uses a specific technique called &quot;Ray Marching&quot; - fairly uncommon among computer graphic softwares, allowing for instance, a very quick rendering of scene with a lot of identical objects (a space filled with infinite spheres for example)."><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2022-07-04T00:00:00.000Z"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://coollibs.github.io//blog/2022/07/04/an-introduction-to-raymarching"><link data-react-helmet="true" rel="alternate" href="https://coollibs.github.io//blog/2022/07/04/an-introduction-to-raymarching" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://coollibs.github.io//blog/2022/07/04/an-introduction-to-raymarching" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fbba7f7.css">
<link rel="preload" href="/assets/js/runtime~main.29eecbe1.js" as="script">
<link rel="preload" href="/assets/js/main.479aad0b.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon-32x32.png" alt="Cool&#x27;s Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/favicon-32x32.png" alt="Cool&#x27;s Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title"></b></a><a class="navbar__item navbar__link" href="/cool">Cool</a><a class="navbar__item navbar__link" href="/lab">Lab</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/contribute">Contribute</a><a class="navbar__item navbar__link" href="/learn">Learn</a><a class="navbar__item navbar__link" href="/internships">Internships</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/CoolLibs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_Pssr toggle_TdHA toggleChecked_cnQY toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">üåú</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">üåû</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" checked="" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">All posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/2022/07/04/an-introduction-to-raymarching">Introduction to raymarching</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/07/04/cool-pros-and-cons">What is cool good at (and not that good) at ? - title to change -</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/29/scripting">How I implemented scripting in two hours</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/28/doing-better-than-cpp-references">Doing better than C++&#x27;s references (&amp;)</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/28/ints-cause-precision-errors">Ints cause precision errors</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/28/the-dear-imgui-model">Ints cause precision errors</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/28/unit-type-system">Unit Type-System</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/26/hijacking-the-dereference-operators">Hijacking the Dereference Operators</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">Introduction to raymarching</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-07-04T00:00:00.000Z" itemprop="datePublished">July 4, 2022</time> ¬∑ <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a itemprop="url"><span itemprop="name">Yvan Smorag</span></a></div></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Cool is a software aimed at visual generative art, meaning it has to <strong>render</strong> - display a 2D or 3D scene onto a computer screen. To do so, Cool uses a specific technique called <strong><em>&quot;Ray Marching&quot;</em></strong> - fairly uncommon among computer graphic softwares, allowing for instance, a very quick rendering of scene with a lot of identical objects (a space filled with infinite spheres for example).<br></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="image-infini-">IMAGE INFINI ?<a class="hash-link" href="#image-infini-" title="Direct link to heading">‚Äã</a></h3><p>In this article we will present this technique and discuss about the pros and cons compared to other rendering methods used in the industry.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="how-do-you-represent-a-3d-image-on-a-2d-screen-">How do you represent a 3D image on a 2D screen ?<a class="hash-link" href="#how-do-you-represent-a-3d-image-on-a-2d-screen-" title="Direct link to heading">‚Äã</a></h3><p>A commonly used way to render a 3D scene is called raytracing, but before explainig you how it works, we need to understand how an image is displayed on screen.
We have a 3D scene, in which we place a camera (i.e the point of view from where we are looking at the scene). From this point, we are watching a 3D scene that we have now to represent on a 2D plane : our computer screen. In order to do so, the process is exactly the same as for drawing. To draw a scene you are looking at with your eye (the camera), you will use the rule of perspective to project it on paper. For 3D images, we are simply replacing paper by the computer monitor. Eventually, we just have to use the perspective rules for each object of the scene and we will have the shape of our 3d scene. <em>Question : Perspective Implement√©e naturellement dans OpenGL non ?</em> Let&#x27;s spice it up with colors !</p><p><img alt="perspective" src="/assets/images/Perspective-cdb70c86cb3e1609a4ed3f3686b24cfa.gif" width="531" height="372"> </p><p>Lofe</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="colors">Colors<a class="hash-link" href="#colors" title="Direct link to heading">‚Äã</a></h3><p>Now that we know how to represent 3d shapes on a 2d screen, we can then make it more realistic, with lights, shadow and colors. In real world, the reason we see objects, is because of <strong><em>photons</em></strong>. They are emitted by sources of light (sun, lamp)..., and will fly through space and time until hitting objects. Once they do so, they have three choices : either being absorbed, re-emitted or transmitted. It is that final bunch of protons emitted and transmitted by the object arriving up to our eyes that will make us &quot;see&quot; the object. For instance, an object reflecting every but &quot;red&quot; photons - light being the sum of all the nuances of colored photons on the visible spectrum - will only emit red photons towards us and therefore look red for the viewer.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="shema-vision-">SHEMA VISION ?<a class="hash-link" href="#shema-vision-" title="Direct link to heading">‚Äã</a></h3><p>Raytracing is a reversed version of what nature does. Instead of computing the reflection of photons emitted by sources and objects up to the camera (that would take far too long), we are going to cast a ray from our camera through every pixel of our screen, and calculate if this ray intersects with an object of our scene. If so, we check if there are any objects between our sources of light, and the point hit by the ray. We can now draw on our screen : if the ray casted from a specific pixel touches a part of an object, we know that we have to project that part of the object according to the distance between the pixel and the object on that particular pixel following the perspective. In addition, if this part of the object is in direct contact with any source of light, the pixel will be enlightened, otherwise it will be shadowy.</p><p><img alt="Raytracing" src="/assets/images/RayTracing_gif-6533954310aa53e2681a210f29839acd.gif" width="531" height="464"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="shema-raytracing-scratcha-pixel">SHEMA RAYTRACING SCRATCHA PIXEL<a class="hash-link" href="#shema-raytracing-scratcha-pixel" title="Direct link to heading">‚Äã</a></h4><p>One of the main concerns in the ray tracing method is finding the intersection between the ray you cast through your pixel (which is a straight line), and the shapes composing the objects of your scene. In practice, objects are often composed of thousands of small triangles or squares (= two triangles), and the goal is to find what triangle is touched by the ray sent through the pixel by the camera (\TROUVER UNE IMAGE MAYBE DE PERSOS DECOMPOSES EN TRIANGLE ?). We know analytically how to test and find an intersection between a straight line (the camera ray) and a triangle but two problems may appear :</p><ol><li>The more complex your scene, the more triangles you get and therefore the more tests and calculs you have to do meaning a longer render time (for instance rendering a very repetitive pattern, thousands of distorted spheres will be very long all the more in real time).</li><li>There are some shapes you can&#x27;t mathematically describe, and therefore you can&#x27;t analytically find an intersection between itself and the ray defined as a straight line. For instance there are forms that you can&#x27;t split in small triangles because of their complexity - such as fractals - or/and because it would imply too many triangles to have a good approximation of it and so, \making render time \explode.</li></ol><p>The question is then : Is there a way to have a fast render for these specific objects (repetitive pattern of objects, fractals...) ? And yes ! Let me introduce to you... ray marching !</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="ray-marching">Ray Marching<a class="hash-link" href="#ray-marching" title="Direct link to heading">‚Äã</a></h3><p>Let&#x27;s summarize. To render an object, you will cast a ray - i.e a straight line - from the camera through every pixel of your screen and find how they intersect - or not - with this object to find out how to project this 3D shape onto your 2D computer monitor, following the rules of perspective. One way to find the intersection is to mathematically compute the straight line - shape intersection, and then figure out -by another intersection calculation - how they interact with lights for placing shadows accordingly ; it is <em>raytracing</em>. Another way to do - and this is what <em>cool</em> uses - is <strong>RayMarching</strong>
RayMarching is a more iterative approach to rendering. Instead of computing an intersection between a straight line and an object, we are going to process by &quot;steps‚Äù along each ray shooted. How does it work ? I will show you right away !</p><p>At every step, we are going to determine the distance from our current position on the ray - the first step being the camera position - to every object of the scene. If none of these distances is close to zero (meaning that the ray is hitting one object) and if we didn&#x27;t reach the max numbers of step, we move on to the next step : we &quot;march&quot; - hence the name of ray<strong>Marching</strong> - of the minimum distance we found between all the objects - in the ray direction. We then repeat the process until the ray meets an object or we arrive at the maximum number of steps. It is an iterative strategy where we march along the ray to determine the collision or not of the ray with the objects within the scene.</p><p>For instance, if my project contains three spheres. I send a ray through a pixel from the camera. I begin the first step at the camera position, and I compute my distances to these spheres : I found s1:2, s2:3, s3:6 meters. I can then surely advance on the ray direction of at least 2 meters (I am sure i won&#x27;t be &quot;inside&quot; an object). I do so and then compute my distances : s1:4, s3:2, s3:1 meters. I advance 1 meter and check the distances again : s1:5, s2:0.01, s3:2.
<strong>0.01</strong> is close enough in my definition to say that the ray is hitting something - here sphere 2. So, I can send to my render algorithm, that on this pixel, 3 meters away following the camera direction (the distance I advanced along the ray in two steps : 2+1) is a part of sphere2, and render it accordingly.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="shema-ray-marchng-3-spheres--le-faire-moi-m√™me">SHEMA RAY MARCHNG 3 SPHERES ? (Le faire moi m√™me)<a class="hash-link" href="#shema-ray-marchng-3-spheres--le-faire-moi-m√™me" title="Direct link to heading">‚Äã</a></h3><p>Thus, unlike raytracing, the issues are not mathematically finding an intersection point, but figuring out an expression of the distance position on the ray to object shape or outline, which is far easier for certain objects (LESQUELS ?).
For example, we can define a distance from any point in space (x, y, z) to a sphere s of center c, and radius r by the formula <em>(first and only math/code function you will see in this page, I promise)</em> :</p><div class="codeBlockContainer_I0IT language-c theme-code-block"><div class="codeBlockContent_wNvx c"><pre tabindex="0" class="prism-code language-c codeBlock_jd64 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token function" style="color:rgb(80, 250, 123)">distance</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">p</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">distance</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">p</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> c</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token operator">-</span><span class="token plain"> r</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(98, 114, 164)">//Distance between the center of the sphere</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                </span><span class="token comment" style="color:rgb(98, 114, 164)">//and the point minus the radius of the sphere</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>(SHEMA ?)</p><p>For a mathematical and coding development, see the bibliography ! üòÑ (rajouter lien √† biblio)</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="pros-and-cons-of-raymarching">Pros and cons of Raymarching<a class="hash-link" href="#pros-and-cons-of-raymarching" title="Direct link to heading">‚Äã</a></h3><p>So, why did we choose to use rayMarching ? (A review avec Jules)</p><ol><li>Innovative. Few softwares use it : allow creativity and a different approach to generative and procedural art (transition pt2)</li><li>RayMarching and cool workflow ==&gt; Combine, blend, twist and apply a lot of different effects of &quot;basic&quot; shapes easy to do in raymarching, allowing to quickly create weird forms, that may be different or more difficult to achieve in other 3D softwares</li><li>Very quick render of a big number of the same objects (meshes vs distance comparison) : possibility to &quot;infinitely&quot; fill a space with a certain shape and navigate through it far fluidier than with meshes : very good for procedural worlds and art in general.</li></ol><p><img alt="infinite_sphere" src="/assets/images/Infinite_Sphere-cfda220542f0043cbf56410633e8c8ff.png" width="1920" height="1080"></p><p>Autre chose ?</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/07/04/cool-pros-and-cons"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">What is cool good at (and not that good) at ? - title to change -</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#image-infini-" class="table-of-contents__link toc-highlight">IMAGE INFINI ?</a></li><li><a href="#how-do-you-represent-a-3d-image-on-a-2d-screen-" class="table-of-contents__link toc-highlight">How do you represent a 3D image on a 2D screen ?</a></li><li><a href="#colors" class="table-of-contents__link toc-highlight">Colors</a></li><li><a href="#shema-vision-" class="table-of-contents__link toc-highlight">SHEMA VISION ?</a></li><li><a href="#ray-marching" class="table-of-contents__link toc-highlight">Ray Marching</a></li><li><a href="#shema-ray-marchng-3-spheres--le-faire-moi-m√™me" class="table-of-contents__link toc-highlight">SHEMA RAY MARCHNG 3 SPHERES ? (Le faire moi m√™me)</a></li><li><a href="#pros-and-cons-of-raymarching" class="table-of-contents__link toc-highlight">Pros and cons of Raymarching</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Our projects</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/CoolLibs/Lab" target="_blank" rel="noopener noreferrer" class="footer__link-item">CoolLab</a></li><li class="footer__item"><a href="https://github.com/CoolLibs/Demo" target="_blank" rel="noopener noreferrer" class="footer__link-item">CoolDemo</a></li></ul></div><div class="col footer__col"><div class="footer__title">Raise an issue!</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/CoolLibs/Cool/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Ask a question</a></li><li class="footer__item"><a href="https://github.com/CoolLibs/Cool/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Give us feedback</a></li><li class="footer__item"><a href="https://github.com/CoolLibs/home/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Report a mistake</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/CoolLibs" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2022. Built with <a href="https://docusaurus.io/">Docusaurus</a>.
                    <div>Icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></div>
                    </div></div></div></footer></div>
<script src="/assets/js/runtime~main.29eecbe1.js"></script>
<script src="/assets/js/main.479aad0b.js"></script>
</body>
</html>